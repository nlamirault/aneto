// Copyright (C) 2015 Nicolas Lamirault <nicolas.lamirault@gmail.com>

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"flag"
	"log"
	"os"
	"path/filepath"

	"github.com/aws/aws-sdk-go/aws"
	"github.com/aws/aws-sdk-go/aws/awsutil"
	"github.com/aws/aws-sdk-go/service/s3"
)

const Version = "0.1.0"

var (
	localPath         string
	bucket            string
	region            string
	printVersion      bool
	printWebsiteFiles bool
	deployWebsite     bool
	doCreateBucket    bool
	doDeleteBucket    bool
)

func init() {
	flag.StringVar(&localPath, "dir", "", "backup directory")
	flag.StringVar(&bucket, "bucket", "", "s3 bucket name")
	flag.StringVar(&region, "region", "", "aws region")
	flag.BoolVar(&doCreateBucket, "create", false, "create bucket")
	flag.BoolVar(&doDeleteBucket, "delete", false, "delete bucket")
	flag.BoolVar(&deployWebsite, "deploy", false, "deploy")
	flag.BoolVar(&printWebsiteFiles, "list", false, "print files")
	flag.BoolVar(&printVersion, "version", false, "print version and exit")
}

func main() {
	flag.Parse()
	if printVersion {
		log.Println("Version", Version)
		os.Exit(0)
	}
	if printWebsiteFiles {
		checkArgument(region, "S3 region")
		checkArgument(bucket, "S3 bucket")
		list()
		os.Exit(0)
	}
	if doCreateBucket {
		checkArgument(region, "S3 region")
		checkArgument(bucket, "S3 bucket")
		createBucket()
	}
	if doDeleteBucket {
		checkArgument(region, "S3 region")
		checkArgument(bucket, "S3 bucket")
		deleteBucket()
	}
	if deployWebsite {
		checkArgument(bucket, "S3 bucket")
		checkArgument(localPath, "website directory")
		checkArgument(region, "S3 region")
		deploy()
	}
}

func checkArgument(key string, value string) {
	if key == "" {
		log.Printf("Please specify %s. Exiting.\n", value)
		os.Exit(1)
	}
}

func getS3Client(region string) *s3.S3 {
	var cfg *aws.Config
	cfg = &aws.Config{Region: aws.String(region)}
	c := s3.New(cfg)
	return c
}

func listObjects(c *s3.S3, b string) ([]string, error) {
	l := make([]string, 0)
	resp, err := c.ListObjects(&s3.ListObjectsInput{
		Bucket: aws.String(b),
	})
	if err != nil {
		return l, err
	}
	for _, k := range resp.Contents {
		//if *k.Size <= 5000 {
		l = append(l, *k.Key)
		//}
	}
	return l, nil
}

func createBucket() {
	log.Println("Create bucket")
	s3Client := getS3Client(region)
	result, err := s3Client.CreateBucket(&s3.CreateBucketInput{
		Bucket: &bucket,
	})
	if err != nil {
		log.Println(err)
		return
	}
	// log.Println("Successfully created bucket", bucket, "in", *result.Location)
	log.Println(awsutil.Prettify(result))
}

func deleteBucket() {
	log.Println("Delete bucket objects")
	s3Client := getS3Client(region)
	list, err := listObjects(s3Client, bucket)
	if err != nil {
		log.Println(err)
		return
	}
	for _, key := range list {
		_, err := s3Client.DeleteObject(&s3.DeleteObjectInput{
			Bucket: &bucket,
			Key:    aws.String(key),
		})
		if err != nil {
			log.Println(err)
			return
		}
	}
	log.Println("Delete bucket")
	result, err := s3Client.DeleteBucket(&s3.DeleteBucketInput{
		Bucket: &bucket,
	})
	if err != nil {
		log.Println(err)
		return
	}
	log.Println(awsutil.Prettify(result))
}

func list() {
	log.Println("Files:")
	s3Client := getS3Client(region)
	list, err := listObjects(s3Client, bucket)
	if err != nil {
		log.Println(err)
		return
	}
	log.Println("Size:", len(list))
	for _, key := range list {
		log.Println("Object: ", key)
	}
}

func deploy() {
	//localPath := "themes/" + theme

	walker := make(fileWalk)
	go func() {
		// Gather the files to upload by walking the path recursively.
		if err := filepath.Walk(localPath, walker.Walk); err != nil {
			log.Fatalln("Walk failed:", err)
		}
		close(walker)
	}()

	// For each file found walking upload it to S3.
	s3Client := getS3Client(region)
	for path := range walker {
		log.Println("Obj:", path)
		rel, err := filepath.Rel(localPath, path)
		if err != nil {
			log.Fatalln("Unable to get relative path:", path, err)
		}
		file, err := os.Open(path)
		if err != nil {
			log.Println("Failed opening file", path, err)
			continue
		}
		defer file.Close()
		result, err := s3Client.PutObject(&s3.PutObjectInput{
			Bucket: &bucket,
			Key:    aws.String(rel),
			Body:   file,
		})
		if err != nil {
			log.Fatalln("Failed to upload data to %s/%s,",
				bucket, path, err)
			return
		}
		log.Printf("Uploaded: %s : %s\n", path, result)
	}
}

type fileWalk chan string

func (f fileWalk) Walk(path string, info os.FileInfo, err error) error {
	if err != nil {
		return err
	}
	if !info.IsDir() {
		f <- path
	}
	return nil
}
